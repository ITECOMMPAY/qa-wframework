# Архитектура

Фреймворк представляет собой набор связанных решений для написания UI-тестов на PHP c использованием Codeception.

UI-тесты по своей сути очень хрупкие и часто ломаются. Задача предоставляемых инструментов — митигировать данный
недостаток за счёт упрощения отладки и починки автотестов.

На данный момент фреймворк состоит из следующих частей:

* **PageComponent'ы** Основная идея фреймворка. Позволяют создать стабильный программный интерфейс к нестабильному,
  постоянно меняющемуся интерфейсу веб-приложения.
* **Умные элементы Селениума** Умеют автоматически находить себя на странице после изменения DOM-дерева, в то время как
  обычные элементы Селениума кидают StaleElementReferenceException.
* **Генерация тестового проекта** Создаёт структуру каталогов тестового проекта и все необходимые классы. Снимает с
  тестировщиков часть рутинной работы.
* **Менеджер Селениума** Слегка облегчает жизнь тестировщикам за счёт автоматического скачивания Selenium Server
  Standalone и свежих драйверов под Chrome и Firefox.
* **HTML-логи** Необходимы для связи происходящего на экране с кодом авто-теста.
* **Хранилище тестовых данных** Обеспечивает централизованное хранение тестовых данных и настроек. Позволяет понять
  состояние тестовой среды на момент падения теста.
* **Словари псевдонимов** Дополняют PageComponent'ы. Помогают отвязать тесты от конкретных надписей на странице.
* **Поддержка BrowserStack** Небольшое расширение базового модуля Codeception для прогона тестов в BrowserStack.
* **Тестирование вёрстки** Создание скриншотов PageObject'ов и сверка с ними в последующих прогонах тестов. Хранение
  скриншотов в S3 бакете.
* **Мягкие ассерты** Нужны в т.ч. для тестирования вёрстки потому что неразумно валить такой тест на первой обводке с
  несовпавшим цветом.

## PageComponent'ы

Интерфейс современных веб-приложений, в основном, пишется на JavaScript с использованием фреймворков Angular и React.
Архитектура обоих основана на компонентах. Компоненты организованы в древовидную структуру.

Для примера, в корне этой структуры может быть компонент Application, который состоит из компонентов Header, Footer,
NavigationPanel и Article. В свою очередь, эти компоненты могут состоять их других компонентов, например,
NavigationPanel может состоять из массива компонентов Button, а Header может состоять из компонентов Logo, Advertising и
Clock.

Эта древовидная структура отображается на DOM-дерево веб-страницы.

В тестах нам приходится совершать обратное отображение, на этот раз DOM-дерева на PageObject'ы. Практика показала, что в
этой ситуации удобно превратить PageObject'ы в компоненты и объединить их в древовидную структуру, похожую на исходную.
Такие PageObject'ы называются PageComponent'ами.

PageComponent'ы делятся на Блоки (WBlock) и Элементы (WElement).

Блоки (`src/Codeception/Lib/WFramework/WebObjects/Base/WBlock/WBlock.php`):

* просто описывают некоторый кусок страницы
* существуют в единственном экземпляре, как и кусок страницы, который они описывают
* не содержат никакой сложной логики — вся их логика снаружи, в тестах

Элементы (`src/Codeception/Lib/WFramework/WebObjects/Base/WElement/WElement.php`):

* описывают кнопки, поля ввода, календари, таблицы, карточки и т.п. повторяющиеся элементы страницы
* существуют во множестве экземпляров, каждый из которых имеет свой локатор
* содержат в себе сложную логику, но для тестов предоставляют простой и понятный интерфейс

Блоки состоят из Элементов. Элементы состоят из других элементов.

Все вместе они собраны в дерево через шаблон Composite (`src/Codeception/Lib/WFramework/Helpers/Composite.php`). Блок
вычисляет свой локатор относительно корня страницы. Элемент вычисляет свой локатор, относительно родительского Блока или
Элемента.

Блоки и Элементы имеют единый интерфейс (`src/Codeception/Lib/WFramework/WebObjects/Base/Interfaces/IPageObject.php`),
который реализован в классе WPageObject (`src/Codeception/Lib/WFramework/WebObjects/Base/WPageObject.php`). В частности,
этот интерфейс содержит is, should и finally методы.

* **is-методы** проверяют заданное условие для PageObject'а и возвращают true или false. Используются в ассертах и
  ветвлениях.
* **finally-методы** ожидают выполнения условия в течение некоторого таймаута и возвращают true или false. Используются
  в ветвлениях. Нужны когда поведение некоторого элемента страницы нестабильно и разработчики не считают это за баг.
* **should-методы** ожидают выполнения условия в течение некоторого таймаута и валят тест если условие так и не
  выполнилось. Активно используются для валидации текущего состояния страницы в начале и конце тестовых шагов.

Помимо блоков и элементов в фреймворке так же имеется псевдо-PageObject под названием Коллекция
элементов  (`src/Codeception/Lib/WFramework/WebObjects/Base/WCollection/WCollection.php`). Она позволяет работать с
динамической группой веб-элементов которые имеют общий локатор, например с вкладками, пунктами меню, строками таблицы.

Коллекция элементов позволяет дождаться появления на странице необходимого количества веб-элементов, обернуть каждый из
них в заданный PageObject и вернуть в виде массива или словаря. В целях оптимизации, коллекция подгружает элементы со
страницы только при вызове своих should и finally методов, а так же при явном вызове своего метода `refresh()`

Коллекция элементов притворяется PageObject'ом и даже реализует IPageObject интерфейс. Реализацию многих методов
IPageObject получилось сделать общей, как для WPageObject, так и для WCollection — эти методы лежат в
трейте `src/Codeception/Lib/WFramework/WebObjects/Base/Traits/PageObjectBaseMethods.php`

В качестве примера работы коллекции можно разобрать следующий пример. Допустим внутри некоторого блока объявлен такой
элемент:

`$tab = DodgeTab::fromXpath('Вкладка', ".//li");`

Это элемент DodgeTab в который будет обёрнут первый элемент по локатору ".//li".

Если на странице отображается три вкладки, то их можно объявить следующим образом:

    $tab1 = DodgeTab::fromXpath('Вкладка 1', ".//li[1]");
    $tab2 = DodgeTab::fromXpath('Вкладка 2', ".//li[2]");
    $tab3 = DodgeTab::fromXpath('Вкладка 3', ".//li[3]");

Но это не слишком удобно. Вместо этого объявление вкладки можно обернуть в коллекцию:

`$tabs = DodgeCollection::fromFirstElement(DodgeTab::fromXpath('Вкладка', ".//li"));`

В данном примере DodgeCollection — это специфичный для проекта наследник WCollection.

После этого элементы коллекции можно подгрузить с помощью should-метода:

`$tabsMap = $tabs->shouldBeEqual(3)->getElementsMap('getAllText');`

Метод `shouldBeEqual(3)` дождётся появления 3 вкладок, а метод `getElementsMap('getAllText')` вернёт ассоциативный
массив, где значениями будут объекты класса DodgeTab, а ключами — результат вызова для каждого из этих элементов
метода `getAllText()`, который возвращает весь текст элемента. Проще говоря, результатом будет ассоциативный
массив `"Текст вкладки" => PageObject вкладки`.

Здесь стоит отметить, что блок будет видеть в списке своих детей псевдо-PageObject DodgeCollection, в то время как
подгруженные DodgeTab будут видеть своим родителем по дереву не DodgeCollection, которая их подгрузила, а блок в котором
она объявлена. Т.е. WCollection прозрачна для PageObject'ов которые она подгружает и непрозрачна для PageObject'а в
котором она объявлена.

### Прокидывание экземпляра RemoteWebDriver в PageObject'ы

Для своей работы PageObject'ам необходима ссылка на актуальный экземпляр RemoteWebDriver. Для передачи его в
PageObject'ы был написан модуль WebTestingModule (`src/Codeception/Module/WebTestingModule.php`), который наследует от
базового модуля Codeception для тестирования веб-UI и добавляет в него метод `getWebDriver()`. WebTestingModule так же
вносит иные изменения и дополнения в модуль Codeception и является основным модулем фреймворка.

Codeception берёт все public методы всех своих подключенных модулей и добавляет их в класс главного Актора проекта. В
примере теста Актором является `tests/dodge/_support/DodgeTester.php`. Внутри него подключен
трейт `tests/dodge/_support/_generated/DodgeTesterActions.php` — через который Codeception и добавляет методы модулей в
Актора при каждом запуске тестов. Таким образом метод `getWebDriver()` будет скопирован внутрь актора. Т.е. внутри
теста `tests/dodge/Tests/exampleCest.php::exampleTest(DodgeTester $I, DodgeSteps $steps)` достаточно
вызвать `$I->getWebDriver()` чтобы получить инстанс драйвера.

Далее в дело вступает DI. Все блоки конкретного тестового проекта наследуют от одного блока, одна из целей которого —
прописать класс актора в конструктор блоков:

`tests/dodge/_support/Helper/Blocks/DodgeBlock.php::__construct(DodgeTester $actor)`

DI срабатывает следующим образом:

Codeception создаёт для теста `/tests/dodge/Tests/exampleCest.php::exampleTest(DodgeTester $I, DodgeSteps $steps)`
экземпляр Актора и экземпляр `tests/dodge/_support/Helper/Steps/DodgeSteps.php`

DodgeSteps нужен только для того чтобы инициализировать все StepObject'ы в проекте без создания кольцевых зависимостей.
Все StepObject'ы прописаны у DodgeSteps в конструкторе и DI создаёт их для него. У каждого StepObject'а в конструкторе
прописаны все необходимые для его работы блоки:

`tests/dodge/_support/Helper/Steps/FrontPageSteps.php::__construct(DodgeTester $I, HeaderBlock $headerBlock, ChooseYourSiteBlock $chooseYourSiteBlock)`

Все блоки в этом проекте наследуют от DodgeBlock и получают в своём конструкторе экземпляр актора. Логика получения и
сохранения драйвера находится внутри WPageObject:

`src/Codeception/Lib/WFramework/WebObjects/Base/WPageObject.php::returnSeleniumServer()`

Он просто дёргает у актора метод `getWebDriver()` и сохраняет драйвер внутри PageObject'а.

Codeception может пересоздавать RemoteWebDriver в процессе прогона тестов. Из-за этого экземпляр RemoteWebDriver внутри
всех PageObject'ов может стать невалидным. Чтобы этого избежать метод `getWebDriver()` возвращает не RemoteWebDriver, а
ProxyWebDriver (`src/Codeception/Lib/WFramework/WebDriverProxies/ProxyWebDriver.php`), который, как следует из его
названия, является прокси-объектом. Он оборачивает RemoteWebDriver и перенаправляет в него все пришедшие сообщения.
Объект ProxyWebDriver передаётся везде по коду тестов и фреймворка.

WebTestingModule следит чтобы внутри ProxyWebDriver всегда был актуальный экземпляр RemoteWebDriver.

### Добавление новых методов в PageObject'ы

Количество PageObject'ов в тестовом проекте растёт до того момента, пока интерфейс веб-приложения не будет полностью
описан. В то время как количество операций и проверок которые нужно применить к PageObject'ам растёт с каждым новым
тестом. Если эти операции и проверки относятся к одному конкретному PageObject'у то их можно добавить методами в его
класс. Но что делать если эти операции и проверки должны быть общими для всех блоков или всех элементов или вообще для
всех PageObject'ов в проекте?

В каждом проекте есть свой уникальный класс для всех блоков (`tests/dodge/_support/Helper/Blocks/DodgeBlock.php`),
наследующий от WBlock, свой класс для всех элементов (`tests/dodge/_support/Helper/Elements/DodgeElement.php`),
наследующий от WElement, и свой класс для всех коллекций (`tests/dodge/_support/Helper/Collections/DodgeCollection.php`)
, наследующий от WCollection.

Можно добавлять код внутрь них. Или если код достаточно общий и полезный чтобы его можно было использовать во всех
тестовых проектах, то его можно добавить в код самого фреймворка на GitHub.

Проблема этого подхода в том, что код соответствующих классов, со временем, распухнет до десятков тысяч строк.

Но есть другое решение. Шаблон Visitor позволяет динамически добавлять новые методы в объекты, причём этот шаблон очень
хорошо подходит к шаблону Composite с помощью которого организованы PageComponent'ы.

Класс `src/Codeception/Lib/WFramework/Helpers/PageObjectVisitor.php` описывает общую структуру всех визиторов для
PageObject'ов.

Все PageObject'ы имеют метод `accept()` который позволяет им принимать визитор, причём если визитор возвращает значение,
то метод `accept()` это значение вернёт.

Визитор PageObject'а позволяет описать действия для каждого отдельного класса PageObject'ов. Для этого внутри него нужно
написать соответствующий accept-метод:

* `acceptWElement()` — описывает поведение визитора для всех наследников WElement т.е. для всех элементов
* `acceptWBlock()` — описывает поведение визитора для всех блоков
* `acceptWCollection()` — для всех коллекций
* `acceptDodgeBlock()` — задаст поведение для всех блоков проекта Dodge
* `acceptWButton()` — опишет поведение для класса WButton и т.д.

Внутри визитора может быть любая комбинация этих методов.

Когда визитор посещает PageObject он ищет внутри себя accept-метод для класса этого PageObject. Если такой метод не
найден, то визитор ищет accept-метод для класса-родителя этого PageObject и т.д. пока не достигнет WBlock, WElement или
WCollection.

Визиторы PageObject'ов можно разделить на три больших группы:

* Операции (Operations)
* Условия (Conditions)
* Объяснения (Explanations)

#### Операции

Операции осуществляют какие-то манипуляции с PageObject'ом. Все операции наследуют
от `src/Codeception/Lib/WFramework/Operations/AbstractOperation.php`.

Примеры операций:

* `src/Codeception/Lib/WFramework/Operations/Mouse/MouseClick.php` — кликает ЛКМ на PageObject
* `src/Codeception/Lib/WFramework/Operations/Get/GetAttributeValue.php` — получает заданный атрибут PageObject

За счёт использования генератора фреймворк добавляет в базовые PageObject'ы тестового проекта Fluent Interface
построенный на основе классов всех операций. Подробнее см. в разделе "Генерация тестового проекта".

#### Условия

Условия проверяют некоторое утверждение о PageObject'е и возвращают true или false. Все условия наследуют
от `src/Codeception/Lib/WFramework/Conditions/AbstractCondition.php`

Примеры условий:

* `src/Codeception/Lib/WFramework/Conditions/Exist.php` — проверяет, что локатор PageObject'а существует в коде страницы
* `src/Codeception/Lib/WFramework/Conditions/Text.php` — проверяет, что PageObject содержит видимый текст (без учёта
  регистра и пробелов)

У всех PageObject'ов, есть универсальные is, should и finally_ методы, которые принимают на вход условие.

#### Объяснения

Объяснения предназначены, в основном, для дебага. В частности, они вызываются в should-методе для отображения подробного
сообщения об ошибке.

После получения результата проверки условия, у условия можно поинтересоваться — почему для данного PageObject'а получен
именно данный результат. Например, почему данный PageObject не содержит данный текст. Это делается с помощью
метода `why(IPageObject $pageObject, bool $actualValue = false) : string`. В метод `why()` нужно передать необходимый
PageObject и результат проверки.

С каждым условием ассоциированы свои Explanations. Например с условием Exist ассоциировано
объяснение `src/Codeception/Lib/WFramework/Explanations/TraverseFromRootExplanation.php` Это объяснение переберёт все
дерево PageObject'ов, начиная от корня и заканчивая заданным PageObject'ом и для каждого из них проверить условие Exist.
Таким образом можно будет например понять, что кнопка не отображается, потому что вся панель на которой она должна быть
— тоже не отображается.

Все объяснения наследуют от `src/Codeception/Lib/WFramework/Explanations/AbstractExplanation.php`

В качестве результата своей работы объяснение возвращает
наследника `src/Codeception/Lib/WFramework/Explanations/Result/AbstractExplanationResult.php`

С условием может быть ассоциировано несколько объяснений. Метод `why()` собирает результаты всех объяснений в дерево с
помощью шаблона Composite, а затем печатает итоговый результат с помощью
Visitor `src/Codeception/Lib/WFramework/Explanations/Formatters/DefaultExplanationResultFormatter.php`

В качестве результата своей работы метод `why()` пока возвращает текст, но в будущем планируется так же возвращать
скриншоты страницы с аннотациями.

## Умные элементы Селениума

После того как RemoteWebDriver нашёл на странице элемент по заданному локатору он возвращает ссылку на него в виде
экземпляра класса RemoteWebElement. Через RemoteWebElement ведётся большая часть взаимодействий с элементом страницы.

Но если DOM-дерево страницы изменилось (что особенно часто происходит в React-приложениях т.к. точечные обновления
DOM-дерева — его главная фича), то RemoteWebElement может потерять свой веб-элемент. Если это случилось, то
RemoteWebElement кидает StaleElementReferenceException или NoSuchElementException и тест падает.

Чтобы этого не происходило RemoteWebElement обёрнут в
прокси-объект `src/Codeception/Lib/WFramework/WebDriverProxies/ProxyWebElement.php` Основная задача этого объекта —
перехватывать такие исключения и находить элемент заново.

В отличие от RemoteWebElement, ProxyWebElement в курсе про древовидную структуру PageObject'ов. Каждый PageObject имеет
свой связанный экземпляр ProxyWebElement. Если локатор PageObject'а определён относительно локатора родительского
PageObject'а, то внутри ProxyWebElement будет ссылка на ProxyWebElement его родителя и искать RemoteWebElement он будет
относительно него.

Это позволило сделать интересную оптимизацию.

Дело в том что при полном обновлении страницы, у всех PageObject'ов, описывающих данную страницу, побьются
RemoteWebElement. Каждому соответствующему ProxyWebElement придётся проверить актуальность своего RemoteWebElement,
узнать, что он неактуален, перехватив NoSuchElementException, и найти его заново. Перехват Exception у сотни объектов —
очень медленный процесс и тесты могут подолгу тупить пока все RemoteWebElement обновятся.

Для решения этой проблемы после получения свежего RemoteWebElement, ProxyWebElement стучится к своему родителю и
прописывает свой уникальный id внутри него. При следующем обращении к ProxyWebElement — он стучится к своему родителю и
проверяет, что родитель всё ещё знает про его id. Если это не так — то ProxyWebElement считает, что его родитель,
который находится выше по DOM-дереву, пересоздавал RemoteWebElement и сам пересоздаёт свой RemoteWebElement, после чего
очищает список id своих детей. Таким образом все дети этого ProxyWebElement тоже пересоздадут свои RemoteWebElement и
очистят список id своих детей и никто из них не словит Exception, кроме самого первого ProxyWebElement в этой цепочке,
который не найдёт свой RemoteWebElement и запустит эту цепную реакцию.

Помимо ProxyWebElement стоит так же упомянуть о `src/Codeception/Lib/WFramework/WebDriverProxies/ProxyWebElements.php`
Этот объект используется внутри WCollection. Если цель WCollection для каждого веб-элемента, из найденных по одному
локатору, создать отдельный PageObject оборачивающий его, то цель ProxyWebElements обернуть все найденные по одному
локатору RemoteWebElement в отдельные ProxyWebElement. По сути WCollection передаёт заданный локатор в ProxyWebElements,
тот вызывает у RemoteWebDriver метод `findElements()` который возвращает массив найденных RemoteWebElement, оборачивает
каждый из них в ProxyWebElement и отдаёт их WCollection, которая оборачивает каждый ProxyWebElement в заданный
PageObject.

## Генерация тестового проекта

Пока фреймворк жил внутри нашей компании все доработки PageObject'ов для каждого проекта можно было вносить прямо в код
их базовых классов: WPageObject, WBlock, WElement, WCollection. Когда было решено оформить фреймворк в отдельную
библиотеку и выложить его в Packagist от этого архитектурного решения пришлось избавляться.

### Генерация базовых классов для PageObject'ов

Первым делом был добавлен механизм визиторов для динамического добавления новых операций и проверок в PageObject'ы.
Далее было решено сделать отдельные классы блоков, элементов и коллекций под каждый тестовый проект. Они, а так же
многие другие вещи, создаются автоматически с помощью генератора структуры тестового проекта.

Основной класс генератора это: `src/Codeception/Lib/WFramework/Generator/WProjectStructure.php `

Его задача — извлечь все необходимые данные из файлов проекта (если они есть) и кода фреймворка и запустить генерацию.

Генератор написан с использованием тех же принципов, что и остальной фреймворк, в частности — шаблонов Composite и
Visitor.

Для начала, на основе полученных данных строится дерево сущностей. Дерево начинается
от `src/Codeception/Lib/WFramework/Generator/ParsingTree/RootNode.php`

RootNode создаёт и добавляет себе в качестве детей остальные сущности:

* `src/Codeception/Lib/WFramework/Generator/ParsingTree/Block/BlockNode.php` — содержит данные для генерации общего
  класса блоков проекта
* `src/Codeception/Lib/WFramework/Generator/ParsingTree/Element/ElementNode.php` — содержит данные для генерации общего
  класса элементов проекта
* `src/Codeception/Lib/WFramework/Generator/ParsingTree/Collection/CollectionNode.php` — содержит данные для генерации
  общего класса коллекций проекта

Далее WProjectStructure запускает генерацию кода для сущностей. Код генерируется с помощью
визитора `src/Codeception/Lib/WFramework/Generator/SourceGenerator/SourceGeneratorVisitor.php`, который применяет к
каждому узлу соответствующий генератор:

* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/BlockSource.php` — генерирует код общего класса блоков на
  основе BlockNode
* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/ElementSource.php` — генерирует код общего класса элементов
  на основе ElementNode
* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/CollectionSource.php` — генерирует код общего класса
  коллекций на основе CollectionNode

Код сохраняется внутри узлов дерева сущностей.

Под конец, WProjectStructure применяет к дереву
визитор `src/Codeception/Lib/WFramework/Generator/FileGenerator/FileGeneratorVisitor.php`, который сохраняет
сгенерированный код в соответствующие файлы.

### Генерация Fluent Interface на основе классов операций

Генератор так же используется для облегчения написания тестов. Например, для упрощения вызова операций.

Вызов визитора для PageObject'а выглядит так: `$attribute = $pageObject->accept(new GetAttributeValue('href'));` Т.к.
ощутимая часть тестов построена вокруг манипуляций над PageObject'ами то на выходе получается код состоящий из портянок
вызовов accept-методов. Чтобы сделать этот код более внятным, для общих классов PageObject'ов проекта генерируются
фасады с Fluent Interface на основе всех операций объявленных в фреймворке и в проекте.

Этот момент можно рассмотреть на примере общего класса блоков тестового
проекта: `tests/dodge/_support/Helper/Blocks/DodgeBlock.php`

WProjectStructure сканирует каталог фреймворка и проекта и извлекает из него все классы операций. Если класс не содержит
в себе accept-метода для блоков, то он пропускается. Иначе — имя класса разделяется на две части. Первое слово станет
названием группы, а второе - названием операции. Например:

* операция GetAttributeValue будет иметь группу `get` и название `attributeValue`
* операция GetScrollSize будет иметь группу `get` и название `scrollSize`
* операция ExecuteScript будет иметь группу `execute` и название `script`
* операция MouseClick будет иметь группу `mouse` и название `click`

Внтури класса блоков прописан метод `returnOperations()`. Этот метод возвращает сгенерированный фасад Operations в
котором будут прописаны методы для всех найденных групп. Метод `get()` будет возвращать сгенерированный класс Get,
метод `execute()` — Execute, метод `mouse()` — Mouse. Внутри класса для каждой группы будут прописаны методы для всех
операций данной группы: `attributeValue()`, `scrollSize()`, `script()`, `click()`. Каждый из этих методов оборачивает
вызов accept для PageObject'а с соответствующим
визитором: `$pageObject->accept(new \Codeception\Lib\WFramework\Operations\Get\GetAttributeValue($attribute));`

За счёт этого кода в тестах вместо `$pageObject->accept(new GetAttributeValue('href'));` можно будет
написать `$pageObject->returnOperations()->get()->attributeValue('href');` , а вместо множества обращений к
методу `accept()` можно будет использовать цепочки методов для выполнения последовательности операций над PageObject'ом:

    $pageObject
            ->returnOperations()
            ->mouse()
            ->scrollTo()
            ->click()
            ->then()
            ->keyboard()
            ->pressKeys('test')
            ->then()
            ->wait()
            ->forHalfTimeout()
            ;

* За описание фасада операций для блока
  отвечает: `src/Codeception/Lib/WFramework/Generator/ParsingTree/Block/BlockFacadeNode.php`
* За описание группы операций для блока
  отвечает: `src/Codeception/Lib/WFramework/Generator/ParsingTree/Block/BlockOperationGroupNode.php`
* За описание отдельного метода с вызовом операции для блока
  отвечает: `src/Codeception/Lib/WFramework/Generator/ParsingTree/Block/BlockOperationNode.php`

Исходники для них генерируют соответствующие классы:

* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/FacadeSource.php`
* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/OperationGroupSource.php`
* `src/Codeception/Lib/WFramework/Generator/SourceGenerator/OperationSource.php`

### Генерация примитивных элементов

Практика показала, что идея создать общие классы для базовых элементов: кнопок, полей ввода, календарей, таблиц — не
взлетает.

Всё потому что поведение этих простых элементов часто разительно отличается между тестовыми проектами. В некоторых
проектах чтобы ввести тест в поле ввода нужно сначала кликнуть по нему и подождать 400 мс анимации. В других - некоторые
кнопки не реагируют на стандартный клик Селениума или вообще представляют собой SVG-картинки и требуют отдельного
подхода. У календарей и таблиц существует масса различных реализаций, которые очень сильно отличаются друг от друга.

Дабы создать классы которые могли бы описать все такие элементы — в них пришлось бы запихнуть очень сложную логику и
прилагать к каждому такому классу по паре десятков параметров для тонкой настройки.

В итоге, от идеи универсальных классов решено было отказаться. А вместо них для каждого тестового проекта генерируются
простые примеры таких классов, которые можно доработать под каждый проект по отдельности. В примере эти классы лежат в
каталоге: `tests/dodge/_support/Helper/Elements/Basic`

За описание этих классов в генераторе отвечают узлы которые лежат
в: `src/Codeception/Lib/WFramework/Generator/ParsingTree/BasicElements`

А код по этим узлам строят классы которые лежат
в: `src/Codeception/Lib/WFramework/Generator/SourceGenerator/BasicElements`

### Запуск генератора

Есть несколько способов запуска генератора.

Генератор можно запустить вручную с помощью команды Codeception. Код команды лежит
в: `src/Codeception/Command/WBuild.php`
Так же генератор можно прописать, как расширение Codeception, чтобы он срабатывал при каждом запуске тестов. Расширение
лежит в: `src/Codeception/Extension/WAutoRebuild.php`

Эти два способа предназначены для тех случаев, когда первоначальная структура проекта уже создана и нужно просто
добавить в неё новые операции или шаги тестов.

Генерацией проекта с нуля занимается шаблон Codeception проекта: `src/Codeception/Template/WProject.php` Он создаёт все
необходимые каталоги, файл настроек, а затем запускает сам генератор.

## Менеджер Селениума

Для прогона тестов Селениума нужно поднять Selenium Server Standalone с драйвером под конкретную версию заданного
браузера. Делать это руками — не удобно.

Пока под PHP не появится полноценный аналог `bonigarcia/webdrivermanager` придётся обходиться самописным менеджером.

Менеджер Селениума реализован в виде Codeception модуля
SeleniumServerModule (`src/Codeception/Module/SeleniumServerModule.php`).

При запуске тестов SeleniumServerModule спрашивает у WebTestingModule — нужно ли поднять сервер Селениума.

WebTestingModule может ответить "нет", например, если тесты будут прогоняться в BrowserStack, который по своей сути
является сервером Селениума на ферме удалённых машин. В таком случае SeleniumServerModule прекращает свою работу.

Если WebTestingModule ответил "да", то SeleniumServerModule лочит порт с
помощью `src/Codeception/Lib/WFramework/Helpers/MultiProcessLock.php` задача которого — гарантировать, что при
параллельном прогоне тестов только один процесс будет запускать и настраивать сервер Селениума, пока остальные — ждут.

Затем модуль проверяет, что сервер Селениума уже поднят. Если это так — то модуль разлочивает порт и завершает свою
работу.

Если нет, то модуль скачивает Selenium Server Standalone с
помощью `src/Codeception/Lib/WFramework/Selenium/Managers/SeleniumServerManager.php`, драйвер под текущую версию Хрома с
помощью `src/Codeception/Lib/WFramework/Selenium/Managers/ChromeDriverManager.php` и драйвер под последний Огнелис с
помощью `src/Codeception/Lib/WFramework/Selenium/Managers/GeckoDriverManager.php`. Если необходимые файлы уже скачаны,
то данные классы просто вернут путь к ним.

После того как все необходимые файлы получены модуль запускает Selenium Server Standalone и разлочивает порт.

## HTML-логи

Визуальные тесты очень хрупкие. Порой сломать тест может тень которая перекрыла середину нужной кнопки или слишком
долгая анимация активации поля ввода. Поэтому когда тест упал часто бывает сложно понять на каком этапе и по какой
причине это произошло.

Большую роль в решении этой проблемы играют логи. Именно они связывают код теста с происходящим на экране. Хорошие логи
могут сократить время поиска проблемы с пары часов до пары минут.

Логи, предоставляемые фреймворком, хранятся в формате HTML. Они состоят из трёх уровней. На верхнем уровне выводятся
логи шагов теста. При клике на запись для шага раскрывается следующий уровень - логи основных систем фреймворка,
например логи операций над PageObject'ами. При клике на запись для операции раскрывается последний уровень с подробной
информацией для дебага.

Логи фреймворка построены на базе Monolog, а стандартные уровни логирования переиспользованы под нужды тестов.

* Notice — для описания шагов тестов
* Info — для логирования операций над PageObject'ами
* Debug — для вывода низкоуровневых логов
* Error — содержит причину падения теста
* Warning — для вывода предупреждений о возможной ошибке в логике теста
* Alert — жёсткие проверки
* Critical — мягкие проверки

Всё логирование внутри кода фреймворка осуществляется через простой
класс `src/Codeception/Lib/WFramework/Logger/WLogger.php`

Этот класс имеет восемь методов для логирования:

* `logAction()` — умный метод, который сам определяет — на какой уровень нужно поместить запись
* `logNotice()`
* `logInfo()`
* `logDebug()`
* `logError()`
* `logWarning()`
* `logAssertHard()` — жёсткие проверки
* `logAssertSoft()` — мягкие проверки

По умолчанию этот класс просто выводит записи в консоль. Для использования HTML-логов нужно подключить модуль
логирования: `src/Codeception/Module/HtmlLoggerModule.php`

Этот модуль настраивает Monolog, а так же предоставляет методы логирования для актора теста. Модуль прописывается в
WLogger через метод `setLoggerModule()`. Когда в WLogger прописан модуль для логирования — он перенаправляет все записи
в него вместо того чтобы выводить их в консоль.

Для вывода лога в HTML используется переработанный Monolog Formatter, который лежит в
каталоге `src/Codeception/Lib/WFramework/Logger/HtmlLogger`

Каждую запись лога (кроме уровня Debug) модуль сопровождает скриншотом веб-страницы. Т.к. логи очень подробные то
скриншотов за время работы теста накапливается по несколько тысяч штук и занимать они могут по паре гигабайт. Для
уменьшения размера логов скриншоты конвертируются в видео с помощью утилиты ffmpeg.

Т.к. ffmpeg может на машине не стоять, то был создан модуль для автоматического скачивания ffmpeg под Linux или
Mac: `src/Codeception/Module/FFmpegManagerModule.php`  Этот модуль работает по тому же принципу, что и менеджер
Селениума.

## Хранилище тестовых данных

Для централизованного хранения тестовых данных и настроек фреймворка были написаны классы:

* `src/Codeception/Lib/WFramework/Properties/GlobalProperties.php` — данные, которые живут на протяжении всего прогона
* `src/Codeception/Lib/WFramework/Properties/SuiteProperties.php` — данные, которые живут на протяжении прогона одной
  группы тестов. В начале прогона каждой группы SuiteProperties очищается и заполняется данными из GlobalProperties
* `src/Codeception/Lib/WFramework/Properties/TestProperties.php` — данные, которые живут на протяжении прогона одного
  теста. В начале прогона каждого теста TestProperties очищается и заполняется данными из SuiteProperties

Данные кладутся в один из указанных классов, но извлекаются всегда из TestProperties.

При падении теста содержимое TestProperties сохраняется рядом с его HTML-логом.

## Словари псевдонимов

AliasMap'ы (`src/Codeception/Lib/WFramework/AliasMaps/AliasMap.php`) — это двухсторонние ассоциативные массивы, где по
ключу можно получить значение, а по значению — ключ. Ключами у нас выступают псевдонимы надписей, а значениями —
реальные надписи на странице.

Везде по тестам у нас передаются псевдонимы, а реальные значения извлекаются из AliasMap только в месте
непосредственного использования. Таким образом мы отвязываем наши тесты от реальных надписей на странице.

## Поддержка BrowserStack

Для поддержки BrowserStack базовый модуль Codeception для тестирования веб-UI был модифицирован в своём
наследнике: `src/Codeception/Module/WebTestingModule.php`

Была реализована передача параметров BrowserStack через переменные среды для случаев прогона тестов в Дженкинсе (
метод `configureBrowserStack()`). А упавшие тесты помечаются в дашборде BrowserStack путём отправки запроса на его API (
метод `_failed()`).

Для случаев прогона тестов в BrowserStack с использованием его локального агента был написан скрипт для Дженкинса,
который этот агент запускает: `src/Codeception/Util/BSStarter.php` Главная задача скрипта — при параллельном запуске
тестов убедиться, что только один процесс запустит локального агента, пока остальные ожидают успешного запуска.

## Тестирование вёрстки

TODO

## Мягкие ассерты

Не всегда удобно валить тест при первой же невалидной проверке. Особенно неудобно это делать в случае тестирования
вёрстки.

Для решения этой проблемы был написан модуль `src/Codeception/Module/WebAssertsModule.php`, который добавляет мягкие
варианты для всех проверок Codeception. В качестве бонуса, этот модуль так же добавляет логирование для всех проверок —
как жёстких так и мягких.

Для реализации мягких проверок в методе `softAssert()` у жёстких проверок перехватывается исключение
AssertionFailedError. Все AssertionFailedError заносятся в массив failedSoftAssertions. В конце теста проверяется, что
массив failedSoftAssertions — пустой (метод `_after()`).